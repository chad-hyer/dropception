import sys
import numpy as np
import pandas as pd
import cv2
import tifffile
from scipy.stats import gaussian_kde
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import openpyxl

#GUI and tool generated by Gemini with instructions from Chad D. Hyer, based on 'Color Quant.py' connected to https://doi.org/10.3390/s24103073

# --- Custom Image Viewer Widget ---
class ImageViewer(QtWidgets.QWidget):
    hover_data_signal = QtCore.pyqtSignal(str) 
    roi_finished_signal = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.channels_data = []     # List of dicts
        self.circles = None         # [[x, y, r], ...]
        self.valid_mask = []
        self.show_circles = True    # Toggle for overlay
        
        # Navigation
        self.scale_factor = 1.0
        self.offset = QtCore.QPointF(0, 0)
        self.is_panning = False
        self.last_mouse_pos = QtCore.QPoint()
        
        # Manual Background
        self.bg_roi_rect = None
        self.drawing_bg = False
        self.bg_mode = "Auto"
        
        self.setMouseTracking(True)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        self.colormaps = {
            "Gray":  [1, 1, 1], "Green": [0, 1, 0], "Red":   [1, 0, 0],
            "Blue":  [0, 0, 1], "Cyan":  [0, 1, 1], "Magenta":[1, 0, 1], "Yellow":[1, 1, 0]
        }
        # Analysis ROI (Crop)
        self.analysis_roi = None # (x, y, w, h)
        self.drawing_roi = False

    def set_data(self, channels_data, circles=None, valid_mask=None):
        """
        channels_data: list of {'data': arr, 'color': 'Green', 'visible': True, 'clip': 0-255}
        """
        self.channels_data = channels_data
        if circles is not None:
            self.circles = circles
            if valid_mask is None:
                self.valid_mask = [True] * len(circles)
            else:
                self.valid_mask = valid_mask
        self.update()

    def fit_to_window(self):
        if not self.channels_data: return
        h, w = self.channels_data[0]['data'].shape
        self.scale_factor = min(self.width() / w, self.height() / h) * 0.9
        view_w, view_h = w * self.scale_factor, h * self.scale_factor
        self.offset = QtCore.QPointF((self.width() - view_w) / 2, (self.height() - view_h) / 2)
        self.update()

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.fillRect(self.rect(), QtCore.Qt.black)

        if not self.channels_data:
            painter.setPen(QtCore.Qt.white)
            painter.drawText(self.rect(), QtCore.Qt.AlignCenter, "No Image Loaded")
            return

        h, w = self.channels_data[0]['data'].shape
        
        # --- 1. Composite Image Layers ---
        # Initialize floating point accumulator for high dynamic range blending
        comp_img = np.zeros((h, w, 3), dtype=np.float32)
        
        has_visible = False
        for ch in self.channels_data:
            if not ch['visible']: continue
            has_visible = True
            
            # Normalize 0-1
            img_float = cv2.normalize(ch['data'].astype(np.float32), None, 0, 1.0, cv2.NORM_MINMAX)
            
            # Apply Clipping (Black Level)
            # Slider is 0-255. We map this to 0.0 - 1.0 threshold.
            clip_thresh = ch['clip'] / 255.0
            
            if clip_thresh > 0:
                # Soft subtract: shift everything down by threshold
                img_float = np.maximum(0, img_float - clip_thresh)
                
                # Optional: Rescale remaining dynamic range to full brightness?
                # Currently disabled to keep relative intensity true to data.
                # if clip_thresh < 1.0: img_float /= (1.0 - clip_thresh)
            
            c_rgb = self.colormaps.get(ch['color'], [1,1,1])
            
            # Additive Blending
            layer = np.dstack([img_float * c_rgb[0], img_float * c_rgb[1], img_float * c_rgb[2]])
            comp_img += layer

        if has_visible:
            # Clip to 0-1 and convert to 8-bit
            comp_img = np.clip(comp_img, 0, 1)
            comp_img = (comp_img * 255).astype(np.uint8)
            qt_img = QtGui.QImage(comp_img.data, w, h, 3 * w, QtGui.QImage.Format_RGB888)
            
            target_rect = QtCore.QRectF(
                self.offset.x(), self.offset.y(),
                w * self.scale_factor, h * self.scale_factor
            )
            painter.drawImage(target_rect, qt_img)

        # --- 2. Draw Circles ---
        if self.circles is not None and self.show_circles:
            painter.setRenderHint(QtGui.QPainter.Antialiasing)
            for i, (x, y, r) in enumerate(self.circles):
                sx = x * self.scale_factor + self.offset.x()
                sy = y * self.scale_factor + self.offset.y()
                sr = r * self.scale_factor

                color = QtCore.Qt.cyan if self.valid_mask[i] else QtCore.Qt.red
                painter.setPen(QtGui.QPen(color, 1))
                painter.drawEllipse(QtCore.QPointF(sx, sy), sr, sr)

        # --- 3. Draw Manual BG ROI ---
        if self.bg_roi_rect is not None:
            rx, ry, rw, rh = self.bg_roi_rect
            sx = rx * self.scale_factor + self.offset.x()
            sy = ry * self.scale_factor + self.offset.y()
            sw = rw * self.scale_factor
            sh = rh * self.scale_factor
            painter.setPen(QtGui.QPen(QtCore.Qt.yellow, 2, QtCore.Qt.DashLine))
            painter.drawRect(QtCore.QRectF(sx, sy, sw, sh))
        
        # 4. Draw Analysis ROI (Green)
        if self.analysis_roi is not None:
            rx, ry, rw, rh = self.analysis_roi
            sx = rx * self.scale_factor + self.offset.x()
            sy = ry * self.scale_factor + self.offset.y()
            sw = rw * self.scale_factor
            sh = rh * self.scale_factor
            
            painter.setPen(QtGui.QPen(QtCore.Qt.green, 2, QtCore.Qt.DashLine))
            painter.drawRect(QtCore.QRectF(sx, sy, sw, sh))
            
            # Optional: Dim outside area?
            # For now, just the box is enough to show the "Valid Zone"

    def wheelEvent(self, event):
        if not self.channels_data: return
        zoom_in = event.angleDelta().y() > 0
        factor = 1.1 if zoom_in else 0.9
        old_scale = self.scale_factor
        self.scale_factor = max(0.01, min(self.scale_factor * factor, 50.0))
        
        mouse_pos = event.pos()
        vec = mouse_pos - self.offset
        self.offset = mouse_pos - vec * (self.scale_factor / old_scale)
        self.update()

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.RightButton:
            self.is_panning = True
            self.last_mouse_pos = event.pos()
        elif event.button() == QtCore.Qt.LeftButton:
            img_pos = self.get_img_coords(event.pos())
            if img_pos:
                mx, my = img_pos
                if self.drawing_roi:
                    self.roi_start = (mx, my)
                elif self.drawing_bg:
                    self.bg_start = (mx, my)
                elif self.circles is not None and self.show_circles:
                     for i, (cx, cy, cr) in enumerate(self.circles):
                        dist = np.sqrt((mx - cx)**2 + (my - cy)**2)
                        if dist < cr:
                            self.valid_mask[i] = not self.valid_mask[i]
                            self.update()
                            break
        

    def mouseMoveEvent(self, event):
        if self.is_panning:
            delta = event.pos() - self.last_mouse_pos
            self.offset += delta
            self.last_mouse_pos = event.pos()
            self.update()
            return

        img_pos = self.get_img_coords(event.pos())
        if not img_pos: return
        mx, my = img_pos

        if self.drawing_bg and event.buttons() & QtCore.Qt.LeftButton:
            x = min(self.bg_start[0], mx); y = min(self.bg_start[1], my)
            w = abs(self.bg_start[0] - mx); h = abs(self.bg_start[1] - my)
            self.bg_roi_rect = (x, y, w, h)
            self.update()

        # Tooltip
        if self.circles is not None and self.show_circles:
            for i, (cx, cy, cr) in enumerate(self.circles):
                dist = np.sqrt((mx - cx)**2 + (my - cy)**2)
                if dist < cr:
                    text = f"<b>ID: {i}</b><br>"
                    for idx, ch in enumerate(self.channels_data):
                        # Quick sample
                        x, y = int(cx), int(cy)
                        if 0 <= y < ch['data'].shape[0] and 0 <= x < ch['data'].shape[1]:
                            val = ch['data'][y, x]
                            text += f"Ch{idx}: {val}<br>"
                    self.hover_data_signal.emit(text)
                    return
            self.hover_data_signal.emit("")
        
        # Dragging Analysis ROI
        if self.drawing_roi and event.buttons() & QtCore.Qt.LeftButton:
            x = min(self.roi_start[0], mx); y = min(self.roi_start[1], my)
            w = abs(self.roi_start[0] - mx); h = abs(self.roi_start[1] - my)
            self.analysis_roi = (x, y, w, h)
            self.update()
            return

    def mouseReleaseEvent(self, event):
        self.is_panning = False
        
        # Handle BG Drawing (Manual Mode)
        if self.drawing_bg: 
            self.drawing_bg = False
            self.update()
        
        # Handle ROI Drawing (Crop Mode)
        if self.drawing_roi:
            self.drawing_roi = False   # Stop drawing internal flag
            self.roi_finished_signal.emit() # <--- Tell MainWindow we are done
            self.update()

    def get_img_coords(self, widget_pos):
        if not self.channels_data: return None
        mx = (widget_pos.x() - self.offset.x()) / self.scale_factor
        my = (widget_pos.y() - self.offset.y()) / self.scale_factor
        return (mx, my)

# --- Channel Control Item ---
class ChannelControlItem(QtWidgets.QWidget):
    changed = QtCore.pyqtSignal()
    
    def __init__(self, index, name):
        super().__init__()
        self.index = index
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        # Visibility
        self.chk_visible = QtWidgets.QCheckBox(name)
        self.chk_visible.setChecked(True if index == 0 else False)
        self.chk_visible.stateChanged.connect(self.changed.emit)
        layout.addWidget(self.chk_visible)
        
        # Color
        self.combo_color = QtWidgets.QComboBox()
        self.combo_color.addItems(["Gray", "Green", "Red", "Blue", "Cyan", "Magenta", "Yellow"])
        
        # Defaults
        defaults = ["Gray", "Green", "Red", "Blue"]
        if index < len(defaults): self.combo_color.setCurrentText(defaults[index])
        self.combo_color.currentIndexChanged.connect(self.changed.emit)
        layout.addWidget(self.combo_color)

        # Clip Slider (Black Level)
        self.slider_clip = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        # Increased range to 255 for full 8-bit control
        self.slider_clip.setRange(0, 255) 
        self.slider_clip.setValue(0)
        self.slider_clip.setFixedWidth(80)
        self.slider_clip.setToolTip("Clip dark background (0-255)")
        self.slider_clip.valueChanged.connect(self.changed.emit)
        layout.addWidget(self.slider_clip)

# --- Main Window ---
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Dropception Quant")
        self.resize(1200, 850)
        self.channels = [] 
        
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.setCentralWidget(self.splitter)

        self.viewer = ImageViewer()
        self.viewer.hover_data_signal.connect(lambda t: self.lbl_info.setText(t))
        self.splitter.addWidget(self.viewer)

        self.controls_widget = QtWidgets.QWidget()
        self.controls_layout = QtWidgets.QVBoxLayout(self.controls_widget)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self.controls_widget)
        scroll.setMinimumWidth(340)
        self.splitter.addWidget(scroll)
        self.setup_controls()
        self.splitter.setSizes([900, 300])
        self.viewer.roi_finished_signal.connect(self.handle_roi_finish)

        # Flatfield Correction Storage
        self.flat_channels = []    # List of normalized flatfield images (numpy arrays)
        self.ff_mapping = {}       # Dict mapping Analysis_Ch_Index -> FF_Ch_Index
        self.use_flatfield = False # Master toggle

        #Cache Storage
        self.cached_processed_images = {} # Key: Channel Index, Value: Processed Image
    
    def refresh_cache(self):
        """
        re-calculates processed images for ALL channels and stores them.
        Call this ONLY when:
        1. New image loaded
        2. New flatfield loaded
        3. Flatfield mapping changes
        4. 'Apply Correction' is toggled
        """
        self.cached_processed_images = {}
        
        if not self.channels: return

        # Process every channel
        for ch_idx, raw in enumerate(self.channels):
            processed = raw
            
            # Apply Flatfield if enabled
            if self.use_flatfield:
                ff_idx = self.ff_mapping.get(ch_idx, -1)
                if ff_idx != -1 and ff_idx < len(self.flat_channels):
                    ff_img = self.flat_channels[ff_idx]
                    
                    # Safety Resize
                    if raw.shape != ff_img.shape:
                        ff_img = cv2.resize(ff_img, (raw.shape[1], raw.shape[0]))
                    
                    # Division
                    with np.errstate(divide='ignore', invalid='ignore'):
                        processed = raw.astype(np.float32) / ff_img
                    
                    processed = np.nan_to_num(processed).astype(raw.dtype)
            
            self.cached_processed_images[ch_idx] = processed
    
    def handle_roi_finish(self):
        """Called when user releases mouse after drawing Green ROI"""
        self.btn_set_roi.setChecked(False) # Uncheck the button
        self.analyze_data()

    def load_flatfield(self):
        # Allow selecting multiple files (to average them) or a single stack
        fnames, _ = QtWidgets.QFileDialog.getOpenFileNames(self, 'Open Flatfield Reference', '', "Images (*.tif *.tiff *.ome.tif)")
        if not fnames: return
        
        try:
            accum_stack = None
            count = 0
            
            # Load and Average all selected files
            for f in fnames:
                with tifffile.TiffFile(f) as tif:
                    data = tif.asarray()
                
                # Fix dimensions to (C, H, W) logic
                if data.ndim == 2: data = data[np.newaxis, :, :]
                elif data.ndim == 3 and data.shape[0] > data.shape[2]: data = np.moveaxis(data, 2, 0)
                
                if accum_stack is None:
                    accum_stack = data.astype(np.float32)
                else:
                    if data.shape == accum_stack.shape:
                        accum_stack += data.astype(np.float32)
                count += 1
            
            # Average
            avg_stack = accum_stack / count
            
            # Normalize (Calculate Correction Matrices)
            # Matrix = Image / Mean(Image). This centers the correction around 1.0.
            self.flat_channels = []
            for i in range(avg_stack.shape[0]):
                ch = avg_stack[i]
                # Avoid divide by zero if image is purely black
                mean_val = np.mean(ch)
                if mean_val > 0:
                    norm_ch = ch / mean_val
                else:
                    norm_ch = np.ones_like(ch) # No correction possible
                self.flat_channels.append(norm_ch)
            
            self.lbl_ff_status.setText(f"Loaded {len(self.flat_channels)} Ch Reference")
            self.btn_map_ff.setEnabled(True)
            self.chk_apply_ff.setEnabled(True)
            
            # Default Mapping (1:1)
            self.ff_mapping = {i: i for i in range(min(len(self.channels), len(self.flat_channels)))}
            self.refresh_cache()
            
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Failed to load flatfield: {e}")

    def open_ff_mapping_dialog(self):
        """Simple dialog to match Analysis Channels to Flatfield Channels"""
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("Map Flatfield Channels")
        layout = QtWidgets.QFormLayout(dlg)
        
        combos = []
        for i, ch in enumerate(self.channels):
            combo = QtWidgets.QComboBox()
            combo.addItem("None", -1)
            for j in range(len(self.flat_channels)):
                combo.addItem(f"Flatfield Ch {j+1}", j)
            
            # Set current selection
            current_ff = self.ff_mapping.get(i, -1)
            if current_ff != -1 and current_ff < len(self.flat_channels):
                combo.setCurrentIndex(current_ff + 1) # +1 because of "None"
                
            layout.addRow(f"Analysis Ch {i+1}:", combo)
            combos.append(combo)
            
        btn_ok = QtWidgets.QPushButton("OK")
        btn_ok.clicked.connect(dlg.accept)
        layout.addRow(btn_ok)
        
        if dlg.exec_() == QtWidgets.QDialog.Accepted:
            # Save mapping
            for i, combo in enumerate(combos):
                self.ff_mapping[i] = combo.currentData()
                self.refresh_cache()
            # Re-process if enabled
            if self.chk_apply_ff.isChecked():
                self.update_viewer()
                self.analyze_data()

    def toggle_flatfield(self):
        self.use_flatfield = self.chk_apply_ff.isChecked()
        self.refresh_cache()
        self.update_viewer()
        self.analyze_data()

    def get_processed_image(self, ch_idx):
        """Helper to get cached image data."""
        if ch_idx in self.cached_processed_images:
            return self.cached_processed_images[ch_idx]
        else:
            # Fallback if cache missed (shouldn't happen if logic is correct)
            return self.channels[ch_idx]

    def setup_controls(self):
        l = self.controls_layout

        # 1. Load
        gb = QtWidgets.QGroupBox("1. File"); v = QtWidgets.QVBoxLayout()
        btn = QtWidgets.QPushButton("Load OME-TIFF"); btn.clicked.connect(self.load_image)
        v.addWidget(btn); gb.setLayout(v); l.addWidget(gb)

        # 2. Channels
        gb = QtWidgets.QGroupBox("2. View Layers"); self.ch_layout = QtWidgets.QVBoxLayout()
        gb.setLayout(self.ch_layout); l.addWidget(gb)

        # --- NEW GROUP: Flatfield Correction ---
        gb_ff = QtWidgets.QGroupBox("Flatfield Correction")
        l_ff = QtWidgets.QVBoxLayout()
        
        # Load Button
        self.btn_load_ff = QtWidgets.QPushButton("Load Flatfield Image(s)")
        self.btn_load_ff.clicked.connect(self.load_flatfield)
        l_ff.addWidget(self.btn_load_ff)
        
        # Status Label
        self.lbl_ff_status = QtWidgets.QLabel("No Reference Loaded")
        self.lbl_ff_status.setStyleSheet("color: gray; font-style: italic;")
        l_ff.addWidget(self.lbl_ff_status)
        
        # Map Channels Button
        self.btn_map_ff = QtWidgets.QPushButton("Map Channels")
        self.btn_map_ff.clicked.connect(self.open_ff_mapping_dialog)
        self.btn_map_ff.setEnabled(False)
        l_ff.addWidget(self.btn_map_ff)
        
        # Enable Checkbox
        self.chk_apply_ff = QtWidgets.QCheckBox("Apply Correction")
        self.chk_apply_ff.toggled.connect(self.toggle_flatfield)
        self.chk_apply_ff.setEnabled(False)
        l_ff.addWidget(self.chk_apply_ff)
        
        gb_ff.setLayout(l_ff)
        l.addWidget(gb_ff)
        # ---------------------------------------

        # 3. Segmentation
        gb = QtWidgets.QGroupBox("3. Segmentation"); v = QtWidgets.QVBoxLayout()
        
        # Toggle Overlay
        self.chk_show_seg = QtWidgets.QCheckBox("Show Cyan Overlay")
        self.chk_show_seg.setChecked(True)
        self.chk_show_seg.toggled.connect(self.toggle_segmentation_view)
        v.addWidget(self.chk_show_seg)

        # Params
        h = QtWidgets.QHBoxLayout()
        self.spin_p1 = QtWidgets.QSpinBox(); self.spin_p1.setRange(1,300); self.spin_p1.setValue(50)
        self.spin_p2 = QtWidgets.QSpinBox(); self.spin_p2.setRange(1,100); self.spin_p2.setValue(30)
        for s in [self.spin_p1, self.spin_p2]: s.valueChanged.connect(self.run_segmentation)
        h.addWidget(QtWidgets.QLabel("Edge:")); h.addWidget(self.spin_p1)
        h.addWidget(QtWidgets.QLabel("Circ:")); h.addWidget(self.spin_p2)
        v.addLayout(h)
        
        h2 = QtWidgets.QHBoxLayout()
        self.spin_minR = QtWidgets.QSpinBox(); self.spin_minR.setRange(5,500); self.spin_minR.setValue(20)
        self.spin_maxR = QtWidgets.QSpinBox(); self.spin_maxR.setRange(5,500); self.spin_maxR.setValue(60)
        for s in [self.spin_minR, self.spin_maxR]: s.valueChanged.connect(self.run_segmentation)
        h2.addWidget(QtWidgets.QLabel("MinR:")); h2.addWidget(self.spin_minR)
        h2.addWidget(QtWidgets.QLabel("MaxR:")); h2.addWidget(self.spin_maxR)
        v.addLayout(h2)
        gb.setLayout(v); l.addWidget(gb)

        # 4. Analysis
        gb = QtWidgets.QGroupBox("4. Analysis"); v = QtWidgets.QVBoxLayout()
        # Crop / ROI
        h_roi = QtWidgets.QHBoxLayout()
        self.btn_set_roi = QtWidgets.QPushButton("Set Analysis ROI (Crop)")
        self.btn_set_roi.setCheckable(True)
        self.btn_set_roi.clicked.connect(self.activate_roi_drawing)
        h_roi.addWidget(self.btn_set_roi)
        
        self.btn_clear_roi = QtWidgets.QPushButton("Reset ROI")
        self.btn_clear_roi.clicked.connect(self.clear_roi)
        h_roi.addWidget(self.btn_clear_roi)
        v.addLayout(h_roi)
        
        # Shrink
        h3 = QtWidgets.QHBoxLayout()
        h3.addWidget(QtWidgets.QLabel("Shrink ROI (px):"))
        self.spin_shrink = QtWidgets.QSpinBox(); self.spin_shrink.setRange(0,50); self.spin_shrink.setValue(5)
        self.spin_shrink.valueChanged.connect(self.analyze_data) # Auto-update on shrink change too
        h3.addWidget(self.spin_shrink)
        v.addLayout(h3)
        
        # BG Mode
        h4 = QtWidgets.QHBoxLayout()
        self.rb_auto = QtWidgets.QRadioButton("Auto BG"); self.rb_auto.setChecked(True)
        self.rb_man = QtWidgets.QRadioButton("Manual BG"); 
        self.rb_man.toggled.connect(lambda: self.viewer.update() or self.btn_draw.setEnabled(self.rb_man.isChecked()))
        h4.addWidget(self.rb_auto); h4.addWidget(self.rb_man)
        v.addLayout(h4)
        
        self.btn_draw = QtWidgets.QPushButton("Draw BG Rect"); self.btn_draw.setCheckable(True); self.btn_draw.setEnabled(False)
        self.btn_draw.clicked.connect(lambda: setattr(self.viewer, 'drawing_bg', self.btn_draw.isChecked()))
        v.addWidget(self.btn_draw)
        
        self.lbl_info = QtWidgets.QLabel("Hover for info...")
        self.lbl_info.setStyleSheet("color: blue; font-weight: bold;")
        v.addWidget(self.lbl_info)
        v.addStretch()

        # Graph Selector
        v.addWidget(QtWidgets.QLabel("<b>Graph Channel:</b>"))
        self.combo_plot_ch = QtWidgets.QComboBox()
        # Connect to analyze_data for instant graph updates
        self.combo_plot_ch.currentIndexChanged.connect(self.analyze_data)
        v.addWidget(self.combo_plot_ch)

        # Actions
        h5 = QtWidgets.QHBoxLayout()
        b_calc = QtWidgets.QPushButton("Refresh Stats"); b_calc.clicked.connect(self.analyze_data)
        b_exp = QtWidgets.QPushButton("Export Data"); b_exp.clicked.connect(self.export_excel)
        h5.addWidget(b_calc); h5.addWidget(b_exp)
        v.addLayout(h5)

        self.lbl_stats = QtWidgets.QLabel("Stats: N/A")
        v.addWidget(self.lbl_stats)
        gb.setLayout(v); l.addWidget(gb)

        # 5. Plot
        self.plot_canvas = PlotCanvas(self, width=4, height=3)
        l.addWidget(self.plot_canvas)
        
        btn_save_plot = QtWidgets.QPushButton("Save Plot Image")
        btn_save_plot.clicked.connect(self.save_plot_image)
        l.addWidget(btn_save_plot)
        
        # --- 6. Droplet Size Group ---
        gb_size = QtWidgets.QGroupBox("5. Droplet Size")
        l_size = QtWidgets.QVBoxLayout()
        
        self.lbl_size_stats = QtWidgets.QLabel("Radius Stats: N/A")
        l_size.addWidget(self.lbl_size_stats)
        
        # New Plot for Radius
        self.plot_radius = PlotCanvasSize(self, width=4, height=3)
        l_size.addWidget(self.plot_radius)

        btn_save_plot_radius = QtWidgets.QPushButton("Save Plot Image")
        btn_save_plot_radius.clicked.connect(self.save_plot_image_radius)
        l_size.addWidget(btn_save_plot_radius)
        
        gb_size.setLayout(l_size)
        l.addWidget(gb_size)

    def load_image(self):
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Open', '', "Images (*.tif *.tiff *.ome.tif)")
        if not fname: return
        with tifffile.TiffFile(fname) as tif:
            data = tif.asarray()
        if data.ndim == 2: data = data[np.newaxis, :, :]
        elif data.ndim == 3 and data.shape[0] > data.shape[2]: data = np.moveaxis(data, 2, 0) # Fix (H,W,C)
        
        self.channels = [data[i] for i in range(data.shape[0])]

        self.refresh_cache()
        
        # Clear Layouts
        for i in reversed(range(self.ch_layout.count())): 
            self.ch_layout.itemAt(i).widget().setParent(None)
        
        self.channel_widgets = []
        self.combo_plot_ch.clear()
        
        # Temporarily block signals to prevent premature triggering
        self.combo_plot_ch.blockSignals(True)
        for i in range(len(self.channels)):
            item = ChannelControlItem(i, f"Channel {i+1}")
            item.changed.connect(self.update_viewer)
            self.ch_layout.addWidget(item)
            self.channel_widgets.append(item)
            self.combo_plot_ch.addItem(f"Channel {i+1}", i)
        self.combo_plot_ch.blockSignals(False)
        
        if len(self.channels) > 1: self.combo_plot_ch.setCurrentIndex(1) # Default to first fluor
        
        self.update_viewer()
        self.viewer.fit_to_window()
        self.run_segmentation()
        self.analyze_data() # Initial Calculation

    def update_viewer(self):
        layers = []
        for w in self.channel_widgets:
            # CHANGE: Use helper method
            img_data = self.get_processed_image(w.index)
            
            layers.append({
                'data': img_data, # <--- Changed from self.channels[w.index]
                'visible': w.chk_visible.isChecked(),
                'color': w.combo_color.currentText(),
                'clip': w.slider_clip.value()
            })
        self.viewer.set_data(layers, self.viewer.circles, self.viewer.valid_mask)

    def toggle_segmentation_view(self):
        self.viewer.show_circles = self.chk_show_seg.isChecked()
        self.viewer.update()

    def run_segmentation(self):
        if not self.channels: return
        img = self.channels[0] # BF
        blur = cv2.GaussianBlur(img, (9,9), 2)
        norm = cv2.normalize(blur, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        
        circles = cv2.HoughCircles(
            norm, cv2.HOUGH_GRADIENT, 1, 
            minDist=self.spin_minR.value()*2,
            param1=self.spin_p1.value(), param2=self.spin_p2.value(),
            minRadius=self.spin_minR.value(), maxRadius=self.spin_maxR.value()
        )
        
        detected = []
        if circles is not None:
            detected = np.round(circles[0, :]).astype("int").tolist()
        
        self.viewer.set_data(self.viewer.channels_data, detected, None)
        self.analyze_data() # Update stats on new segmentation

    def get_bg_val(self, ch_idx):
        # CHANGE: Use the helper to get the potentially Flatfield-corrected image
        img = self.get_processed_image(ch_idx) 
        
        # 1. Determine the "Universe" (Full image or Crop)
        if self.viewer.analysis_roi:
            rx, ry, rw, rh = map(int, self.viewer.analysis_roi)
            # Clip to image bounds
            rx = max(0, rx); ry = max(0, ry)
            rw = min(rw, img.shape[1] - rx); rh = min(rh, img.shape[0] - ry)
            universe = img[ry:ry+rh, rx:rx+rw]
            offset_x, offset_y = rx, ry
        else:
            universe = img
            offset_x, offset_y = 0, 0

        # 2. Manual BG Mode
        if self.rb_man.isChecked() and self.viewer.bg_roi_rect:
            bx, by, bw, bh = self.viewer.bg_roi_rect
            roi = img[int(by):int(by+bh), int(bx):int(bx+bw)]
            return np.mean(roi) if roi.size else 0
        
        # 3. Auto BG Mode
        mask = np.zeros(universe.shape, dtype=np.uint8)
        if self.viewer.circles:
            for (cx, cy, cr) in self.viewer.circles:
                lx = int(cx - offset_x)
                ly = int(cy - offset_y)
                if 0 <= lx < universe.shape[1] and 0 <= ly < universe.shape[0]:
                    cv2.circle(mask, (lx, ly), int(cr), 255, -1)
        
        bg_mask = cv2.bitwise_not(mask)
        return cv2.mean(universe, mask=bg_mask)[0]

    def analyze_data(self):
        if not self.viewer.circles: return
        
        ch_idx = self.combo_plot_ch.currentData()
        if ch_idx is None: return 
        
        shrink = self.spin_shrink.value()
        
        # 1. Get Background 
        bg_val = self.get_bg_val(ch_idx)
        
        # 2. Parse ROI & Calculate Area
        roi = self.viewer.analysis_roi
        if roi: 
            rx, ry, rw, rh = roi
            area = rw * rh
        else:
            h, w = self.channels[0].shape
            area = w * h
        
        vals = []
        radii = [] # NEW: List to store radius values
        
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            if not self.viewer.valid_mask[i]: continue
            
            # 3. ROI Filter
            if roi:
                if not (rx <= cx <= rx + rw and ry <= cy <= ry + rh):
                    continue

            # Collect Radius (using Brightfield radius 'cr')
            radii.append(cr)

            eff_r = max(1, cr - shrink)
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(eff_r), 255, -1)
            
            img_data = self.get_processed_image(ch_idx)
            raw = cv2.mean(img_data, mask=mask)[0]
            vals.append(raw - bg_val)
            
        if vals:
            # --- Update Intensity Plot (Existing) ---
            peak_kde, kde_x, kde_y = self.plot_canvas.plot(vals, f"Ch {ch_idx+1} Intensity")
            mu, std = np.mean(vals), np.std(vals)
            n_val = len(vals)
            density = n_val / area if area > 0 else 0
            self.lbl_stats.setText(f"N={n_val} | Conc={density:.2e} /pxÂ²\nMean: {mu:.1f} | Std: {std:.1f}\nKDE Peak: {peak_kde:.1f}")

            # --- Update Radius Plot (NEW) ---
            # Plot Histogram & KDE
            r_peak, _, _ = self.plot_radius.plot(radii, "Radius Distribution")
            
            # Calculate Stats
            r_mu, r_std = np.mean(radii), np.std(radii)
            r_cv = (r_std / r_mu * 100) if r_mu > 0 else 0 # Coeff of Variation
            
            self.lbl_size_stats.setText(
                f"Mean R: {r_mu:.1f} px | Std: {r_std:.1f}\n"
                f"CV: {r_cv:.1f}% | Peak: {r_peak:.1f}"
            )

        else:
            self.lbl_stats.setText("No droplets found in ROI.")
            self.lbl_size_stats.setText("No droplets found.")
            self.plot_canvas.axes.clear(); self.plot_canvas.draw()
            self.plot_radius.axes.clear(); self.plot_radius.draw()

    def export_csv(self):
        if not self.viewer.circles: return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save", "res.csv", "CSV (*.csv)")
        if not path: return
        
        shrink = self.spin_shrink.value()
        bgs = [self.get_bg_val(i) for i in range(len(self.channels))]
        
        data = []
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            row = {"ID": i, "Valid": self.viewer.valid_mask[i], "R_BF": cr, "R_Fluor": max(1, cr-shrink)}
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(row['R_Fluor']), 255, -1)
            
            for idx, img in enumerate(self.channels):
                raw = cv2.mean(img, mask=mask)[0]
                row[f"Ch{idx+1}_Raw"] = raw
                row[f"Ch{idx+1}_Net"] = raw - bgs[idx]
            data.append(row)
        pd.DataFrame(data).to_csv(path, index=False)
    
    def export_excel(self):
        if not self.viewer.circles: return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Excel", "results.xlsx", "Excel Files (*.xlsx)")
        if not path: return

        shrink = self.spin_shrink.value()
        
        # 1. Determine Area and ROI String
        roi_str = "Full Image"
        if self.viewer.analysis_roi:
            rx, ry, rw, rh = self.viewer.analysis_roi
            area = rw * rh
            roi_str = f"Crop (x={int(rx)}, y={int(ry)}, w={int(rw)}, h={int(rh)})"
        else:
            h, w = self.channels[0].shape
            area = w * h

        # 2. Setup Parameters
        params = {
            "Edge Thresh": self.spin_p1.value(),
            "Circ Thresh": self.spin_p2.value(),
            "Min/Max Radius": f"{self.spin_minR.value()}-{self.spin_maxR.value()}",
            "Shrink ROI": shrink,
            "Background Mode": "Manual" if self.rb_man.isChecked() else "Auto (Crop)" if self.viewer.analysis_roi else "Auto (Full)",
            "Analysis Region": roi_str,
            "Total Area (px^2)": area
        }
        df_params = pd.DataFrame(list(params.items()), columns=["Parameter", "Value"])

        # 3. Pre-calculate Backgrounds 
        bgs = [self.get_bg_val(i) for i in range(len(self.channels))]
        
        # 4. Filter Data (ROI)
        roi = self.viewer.analysis_roi
        if roi: rx, ry, rw, rh = roi

        data = []
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            if roi:
                if not (rx <= cx <= rx + rw and ry <= cy <= ry + rh):
                    continue 

            row = {"ID": i, "Valid": self.viewer.valid_mask[i], "R_BF": cr, "R_Fluor": max(1, cr-shrink)}
            
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(row['R_Fluor']), 255, -1)
            
            for idx in range(len(self.channels)):
                
                # 1. Get the image (Corrected if FF is on, Raw if FF is off)
                img = self.get_processed_image(idx)
                
                # 2. Calculate mean intensity inside the droplet mask
                # The variable 'raw' now represents the Flatfield Corrected intensity
                raw = cv2.mean(img, mask=mask)[0]
                
                bg = bgs[idx] # This was pre-calculated using get_bg_val (which uses corrected img)
                
                # 3. Store the values
                row[f"Ch{idx+1}_Raw"] = raw
                row[f"Ch{idx+1}_BG"] = bg
                row[f"Ch{idx+1}_Net"] = raw - bg
            
            data.append(row)
        
        df_details = pd.DataFrame(data)

        # 5. Summary Stats with Density
        stats_list = []
        if not df_details.empty:
            valid_df = df_details[df_details["Valid"] == True]

            r_vals = valid_df["R_BF"].values
            if len(r_vals) > 0:
                r_mu, r_std = np.mean(r_vals), np.std(r_vals)
                try:
                    kde = gaussian_kde(r_vals)
                    x = np.linspace(min(r_vals), max(r_vals), 200)
                    r_peak = x[np.argmax(kde(x))]
                except: r_peak = 0
                
                stats_list.append({
                    "Channel": "Size (Radius)",
                    "N (Count)": len(r_vals),
                    "Mean": r_mu,
                    "Std Dev": r_std,
                    "KDE Peak": r_peak
                })
            
            for idx in range(len(self.channels)):
                col = f"Ch{idx+1}_Net"
                if col in valid_df.columns:
                    vals = valid_df[col].values
                    if len(vals) > 0:
                        mu, std = np.mean(vals), np.std(vals)
                        try:
                            kde = gaussian_kde(vals)
                            x = np.linspace(min(vals), max(vals), 200)
                            peak = x[np.argmax(kde(x))]
                        except: peak = 0
                        
                        n_val = len(vals)
                        density = n_val / area if area > 0 else 0
                        
                        stats_list.append({
                            "Channel": f"Ch {idx+1}",
                            "N (Count)": n_val,
                            "Area (px^2)": area,
                            "Density (N/px^2)": density,
                            "Mean": mu,
                            "Std Dev": std,
                            "KDE Peak": peak,
                            "Background Used": bgs[idx]
                        })
        
        df_stats = pd.DataFrame(stats_list)

        # 6. Write to Excel
        try:
            with pd.ExcelWriter(path) as writer:
                df_params.to_excel(writer, sheet_name='Summary', startrow=0, index=False)
                df_stats.to_excel(writer, sheet_name='Summary', startrow=len(df_params)+3, index=False)
                if not df_details.empty:
                    df_details.to_excel(writer, sheet_name='Droplet Data', index=False)
            QtWidgets.QMessageBox.information(self, "Success", "Export Complete")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Failed to save:\n{e}")

    def save_plot_image(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Plot", "plot.png", "Images (*.png *.pdf)")
        if path:
            self.plot_canvas.figure.savefig(path)

    def save_plot_image_radius(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Plot", "plot.png", "Images (*.png *.pdf)")
        if path:
            self.plot_radius.figure.savefig(path)
    
    def get_local_bg(self, ch_img, cx, cy, r_inner, r_outer, all_circles):
        """
        Calculates median intensity of an annulus (donut) around the droplet,
        masking out neighbors to avoid contamination.
        """
        h, w = ch_img.shape
        
        # 1. Create the Annulus Mask (Donut)
        mask = np.zeros((h, w), dtype=np.uint8)
        cv2.circle(mask, (int(cx), int(cy)), int(r_outer), 255, -1)
        cv2.circle(mask, (int(cx), int(cy)), int(r_inner), 0, -1)
        
        # 2. Exclude ANY other droplet from this background area
        # (This prevents a bright neighbor from skewing the background high)
        if all_circles:
            for (ncx, ncy, nr) in all_circles:
                # If neighbor is close to our annulus, mask it out
                dist = np.sqrt((cx-ncx)**2 + (cy-ncy)**2)
                if dist < (r_outer + nr): 
                    cv2.circle(mask, (int(ncx), int(ncy)), int(nr), 0, -1)

        # 3. Calculate Median of remaining pixels
        # If the ring is totally full of neighbors, fallback to 0 or global mean
        locs = np.where(mask > 0)
        if len(locs[0]) == 0:
            return 0 
        
        bg_pixels = ch_img[locs]
        return np.median(bg_pixels)
    
    def activate_roi_drawing(self):
        self.viewer.drawing_roi = self.btn_set_roi.isChecked()
        self.viewer.drawing_bg = False # Turn off BG drawing if on
        self.btn_draw.setChecked(False)

    def clear_roi(self):
        self.viewer.analysis_roi = None
        self.viewer.update()
        self.analyze_data()

# --- Plotter ---
class PlotCanvas(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4):
        # 1. Initialize Figure
        fig = Figure(figsize=(width, height), dpi=100)
        self.axes = fig.add_subplot(111)
        
        # 2. Adjust layout to prevent label clipping
        fig.tight_layout() 
        
        super().__init__(fig)
        self.setParent(parent)

        # 3. --- THE FIX: Enforce Minimum Height ---
        # This tells the layout engine: "Do not shrink me smaller than 250 pixels"
        # Since this is inside a ScrollArea, this will force the scrollbar to appear
        # rather than squishing the graph.
        self.setMinimumHeight(250) 
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)

    def plot(self, data, title):
        self.axes.clear()
        self.axes.hist(data, bins=30, density=True, alpha=0.5, color='skyblue', label='Hist')
        peak = 0
        kde_x, kde_y = None, None
        if len(data) > 1:
            try:
                kde = gaussian_kde(data)
                x = np.linspace(min(data), max(data), 200)
                y = kde(x)
                self.axes.plot(x, y, 'r-', lw=2, label='KDE')
                peak = x[np.argmax(y)]
                kde_x, kde_y = x, y
            except: pass
        self.axes.set_title(title, fontweight=600, fontsize=14)
        self.axes.set_ylabel('Density', fontsize=12)
        self.axes.set_xlabel('DE Intensity (RFU)', fontsize=12)
        self.axes.legend()
        self.figure.tight_layout() # Ensure labels don't get cut off during updates
        self.draw()
        return peak, kde_x, kde_y

class PlotCanvasSize(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4):
        # 1. Initialize Figure
        fig = Figure(figsize=(width, height), dpi=100)
        self.axes = fig.add_subplot(111)
        
        # 2. Adjust layout to prevent label clipping
        fig.tight_layout() 
        
        super().__init__(fig)
        self.setParent(parent)

        # 3. --- THE FIX: Enforce Minimum Height ---
        # This tells the layout engine: "Do not shrink me smaller than 250 pixels"
        # Since this is inside a ScrollArea, this will force the scrollbar to appear
        # rather than squishing the graph.
        self.setMinimumHeight(250) 
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)

    def plot(self, data, title):
        self.axes.clear()
        self.axes.hist(data, bins=30, density=True, alpha=0.5, color='skyblue', label='Hist')
        peak = 0
        kde_x, kde_y = None, None
        if len(data) > 1:
            try:
                kde = gaussian_kde(data)
                x = np.linspace(min(data), max(data), 200)
                y = kde(x)
                self.axes.plot(x, y, 'r-', lw=2, label='KDE')
                peak = x[np.argmax(y)]
                kde_x, kde_y = x, y
            except: pass
        self.axes.set_title(title, fontweight=600, fontsize=14)
        self.axes.set_ylabel('Density', fontsize=12)
        self.axes.set_xlabel('DE Radius (px)', fontsize=12)
        self.axes.legend()
        self.figure.tight_layout() # Ensure labels don't get cut off during updates
        self.draw()
        return peak, kde_x, kde_y

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())