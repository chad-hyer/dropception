import sys
import numpy as np
import pandas as pd
import cv2
import tifffile
from scipy.stats import gaussian_kde
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import openpyxl

#GUI and tool generated by Gemini with instructions from Chad D. Hyer, based on 'Color Quant.py' connected to https://doi.org/10.3390/s24103073

# --- Custom Image Viewer Widget ---
class ImageViewer(QtWidgets.QWidget):
    hover_data_signal = QtCore.pyqtSignal(str) 
    roi_finished_signal = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.channels_data = []     # List of dicts
        self.circles = None         # [[x, y, r], ...]
        self.valid_mask = []
        self.show_circles = True    # Toggle for overlay
        
        # Navigation
        self.scale_factor = 1.0
        self.offset = QtCore.QPointF(0, 0)
        self.is_panning = False
        self.last_mouse_pos = QtCore.QPoint()
        
        # Manual Background
        self.bg_roi_rect = None
        self.drawing_bg = False
        self.bg_mode = "Auto"
        
        self.setMouseTracking(True)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        self.colormaps = {
            "Gray":  [1, 1, 1], "Green": [0, 1, 0], "Red":   [1, 0, 0],
            "Blue":  [0, 0, 1], "Cyan":  [0, 1, 1], "Magenta":[1, 0, 1], "Yellow":[1, 1, 0]
        }
        # Analysis ROI (Crop)
        self.analysis_roi = None # (x, y, w, h)
        self.drawing_roi = False

    def set_data(self, channels_data, circles=None, valid_mask=None):
        """
        channels_data: list of {'data': arr, 'color': 'Green', 'visible': True, 'clip': 0-255}
        """
        self.channels_data = channels_data
        if circles is not None:
            self.circles = circles
            if valid_mask is None:
                self.valid_mask = [True] * len(circles)
            else:
                self.valid_mask = valid_mask
        self.update()

    def fit_to_window(self):
        if not self.channels_data: return
        h, w = self.channels_data[0]['data'].shape
        self.scale_factor = min(self.width() / w, self.height() / h) * 0.9
        view_w, view_h = w * self.scale_factor, h * self.scale_factor
        self.offset = QtCore.QPointF((self.width() - view_w) / 2, (self.height() - view_h) / 2)
        self.update()

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.fillRect(self.rect(), QtCore.Qt.black)

        if not self.channels_data:
            painter.setPen(QtCore.Qt.white)
            painter.drawText(self.rect(), QtCore.Qt.AlignCenter, "No Image Loaded")
            return

        h, w = self.channels_data[0]['data'].shape
        
        # --- 1. Composite Image Layers ---
        # Initialize floating point accumulator for high dynamic range blending
        comp_img = np.zeros((h, w, 3), dtype=np.float32)
        
        has_visible = False
        for ch in self.channels_data:
            if not ch['visible']: continue
            has_visible = True
            
            # Normalize 0-1
            img_float = cv2.normalize(ch['data'].astype(np.float32), None, 0, 1.0, cv2.NORM_MINMAX)
            
            # Apply Clipping (Black Level)
            # Slider is 0-255. We map this to 0.0 - 1.0 threshold.
            clip_thresh = ch['clip'] / 255.0
            
            if clip_thresh > 0:
                # Soft subtract: shift everything down by threshold
                img_float = np.maximum(0, img_float - clip_thresh)
                
                # Optional: Rescale remaining dynamic range to full brightness?
                # Currently disabled to keep relative intensity true to data.
                # if clip_thresh < 1.0: img_float /= (1.0 - clip_thresh)
            
            c_rgb = self.colormaps.get(ch['color'], [1,1,1])
            
            # Additive Blending
            layer = np.dstack([img_float * c_rgb[0], img_float * c_rgb[1], img_float * c_rgb[2]])
            comp_img += layer

        if has_visible:
            # Clip to 0-1 and convert to 8-bit
            comp_img = np.clip(comp_img, 0, 1)
            comp_img = (comp_img * 255).astype(np.uint8)
            qt_img = QtGui.QImage(comp_img.data, w, h, 3 * w, QtGui.QImage.Format_RGB888)
            
            target_rect = QtCore.QRectF(
                self.offset.x(), self.offset.y(),
                w * self.scale_factor, h * self.scale_factor
            )
            painter.drawImage(target_rect, qt_img)

        # --- 2. Draw Circles ---
        if self.circles is not None and self.show_circles:
            painter.setRenderHint(QtGui.QPainter.Antialiasing)
            for i, (x, y, r) in enumerate(self.circles):
                sx = x * self.scale_factor + self.offset.x()
                sy = y * self.scale_factor + self.offset.y()
                sr = r * self.scale_factor

                color = QtCore.Qt.cyan if self.valid_mask[i] else QtCore.Qt.red
                painter.setPen(QtGui.QPen(color, 1))
                painter.drawEllipse(QtCore.QPointF(sx, sy), sr, sr)

        # --- 3. Draw Manual BG ROI ---
        if self.bg_roi_rect is not None:
            rx, ry, rw, rh = self.bg_roi_rect
            sx = rx * self.scale_factor + self.offset.x()
            sy = ry * self.scale_factor + self.offset.y()
            sw = rw * self.scale_factor
            sh = rh * self.scale_factor
            painter.setPen(QtGui.QPen(QtCore.Qt.yellow, 2, QtCore.Qt.DashLine))
            painter.drawRect(QtCore.QRectF(sx, sy, sw, sh))
        
        # 4. Draw Analysis ROI (Green)
        if self.analysis_roi is not None:
            rx, ry, rw, rh = self.analysis_roi
            sx = rx * self.scale_factor + self.offset.x()
            sy = ry * self.scale_factor + self.offset.y()
            sw = rw * self.scale_factor
            sh = rh * self.scale_factor
            
            painter.setPen(QtGui.QPen(QtCore.Qt.green, 2, QtCore.Qt.DashLine))
            painter.drawRect(QtCore.QRectF(sx, sy, sw, sh))
            
            # Optional: Dim outside area?
            # For now, just the box is enough to show the "Valid Zone"

    def wheelEvent(self, event):
        if not self.channels_data: return
        zoom_in = event.angleDelta().y() > 0
        factor = 1.1 if zoom_in else 0.9
        old_scale = self.scale_factor
        self.scale_factor = max(0.01, min(self.scale_factor * factor, 50.0))
        
        mouse_pos = event.pos()
        vec = mouse_pos - self.offset
        self.offset = mouse_pos - vec * (self.scale_factor / old_scale)
        self.update()

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.RightButton:
            self.is_panning = True
            self.last_mouse_pos = event.pos()
        elif event.button() == QtCore.Qt.LeftButton:
            img_pos = self.get_img_coords(event.pos())
            if img_pos:
                mx, my = img_pos
                if self.drawing_roi:
                    self.roi_start = (mx, my)
                elif self.drawing_bg:
                    self.bg_start = (mx, my)
                elif self.circles is not None and self.show_circles:
                     for i, (cx, cy, cr) in enumerate(self.circles):
                        dist = np.sqrt((mx - cx)**2 + (my - cy)**2)
                        if dist < cr:
                            self.valid_mask[i] = not self.valid_mask[i]
                            self.update()
                            break
        

    def mouseMoveEvent(self, event):
        if self.is_panning:
            delta = event.pos() - self.last_mouse_pos
            self.offset += delta
            self.last_mouse_pos = event.pos()
            self.update()
            return

        img_pos = self.get_img_coords(event.pos())
        if not img_pos: return
        mx, my = img_pos

        if self.drawing_bg and event.buttons() & QtCore.Qt.LeftButton:
            x = min(self.bg_start[0], mx); y = min(self.bg_start[1], my)
            w = abs(self.bg_start[0] - mx); h = abs(self.bg_start[1] - my)
            self.bg_roi_rect = (x, y, w, h)
            self.update()

        # Tooltip
        if self.circles is not None and self.show_circles:
            for i, (cx, cy, cr) in enumerate(self.circles):
                dist = np.sqrt((mx - cx)**2 + (my - cy)**2)
                if dist < cr:
                    text = f"<b>ID: {i}</b><br>"
                    for idx, ch in enumerate(self.channels_data):
                        # Quick sample
                        x, y = int(cx), int(cy)
                        if 0 <= y < ch['data'].shape[0] and 0 <= x < ch['data'].shape[1]:
                            val = ch['data'][y, x]
                            text += f"Ch{idx}: {val}<br>"
                    self.hover_data_signal.emit(text)
                    return
            self.hover_data_signal.emit("")
        
        # Dragging Analysis ROI
        if self.drawing_roi and event.buttons() & QtCore.Qt.LeftButton:
            x = min(self.roi_start[0], mx); y = min(self.roi_start[1], my)
            w = abs(self.roi_start[0] - mx); h = abs(self.roi_start[1] - my)
            self.analysis_roi = (x, y, w, h)
            self.update()
            return

    def mouseReleaseEvent(self, event):
        self.is_panning = False
        
        # Handle BG Drawing (Manual Mode)
        if self.drawing_bg: 
            self.drawing_bg = False
            self.update()
        
        # Handle ROI Drawing (Crop Mode)
        if self.drawing_roi:
            self.drawing_roi = False   # Stop drawing internal flag
            self.roi_finished_signal.emit() # <--- Tell MainWindow we are done
            self.update()

    def get_img_coords(self, widget_pos):
        if not self.channels_data: return None
        mx = (widget_pos.x() - self.offset.x()) / self.scale_factor
        my = (widget_pos.y() - self.offset.y()) / self.scale_factor
        return (mx, my)

# --- Channel Control Item ---
class ChannelControlItem(QtWidgets.QWidget):
    changed = QtCore.pyqtSignal()
    
    def __init__(self, index, name):
        super().__init__()
        self.index = index
        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        
        # Visibility
        self.chk_visible = QtWidgets.QCheckBox(name)
        self.chk_visible.setChecked(True if index == 0 else False)
        self.chk_visible.stateChanged.connect(self.changed.emit)
        layout.addWidget(self.chk_visible)
        
        # Color
        self.combo_color = QtWidgets.QComboBox()
        self.combo_color.addItems(["Gray", "Green", "Red", "Blue", "Cyan", "Magenta", "Yellow"])
        
        # Defaults
        defaults = ["Gray", "Green", "Red", "Blue"]
        if index < len(defaults): self.combo_color.setCurrentText(defaults[index])
        self.combo_color.currentIndexChanged.connect(self.changed.emit)
        layout.addWidget(self.combo_color)

        # Clip Slider (Black Level)
        self.slider_clip = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        # Increased range to 255 for full 8-bit control
        self.slider_clip.setRange(0, 255) 
        self.slider_clip.setValue(0)
        self.slider_clip.setFixedWidth(80)
        self.slider_clip.setToolTip("Clip dark background (0-255)")
        self.slider_clip.valueChanged.connect(self.changed.emit)
        layout.addWidget(self.slider_clip)

# --- Main Window ---
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Dropception Quant")
        self.resize(1200, 850)
        self.channels = [] 
        
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.setCentralWidget(self.splitter)

        self.viewer = ImageViewer()
        self.viewer.hover_data_signal.connect(lambda t: self.lbl_info.setText(t))
        self.splitter.addWidget(self.viewer)

        self.controls_widget = QtWidgets.QWidget()
        self.controls_layout = QtWidgets.QVBoxLayout(self.controls_widget)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self.controls_widget)
        scroll.setMinimumWidth(340)
        self.splitter.addWidget(scroll)
        self.setup_controls()
        self.splitter.setSizes([900, 300])
        self.viewer.roi_finished_signal.connect(self.handle_roi_finish)
    
    def handle_roi_finish(self):
        """Called when user releases mouse after drawing Green ROI"""
        self.btn_set_roi.setChecked(False) # Uncheck the button
        self.analyze_data()

    def setup_controls(self):
        l = self.controls_layout

        # 1. Load
        gb = QtWidgets.QGroupBox("1. File"); v = QtWidgets.QVBoxLayout()
        btn = QtWidgets.QPushButton("Load OME-TIFF"); btn.clicked.connect(self.load_image)
        v.addWidget(btn); gb.setLayout(v); l.addWidget(gb)

        # 2. Channels
        gb = QtWidgets.QGroupBox("2. View Layers"); self.ch_layout = QtWidgets.QVBoxLayout()
        gb.setLayout(self.ch_layout); l.addWidget(gb)

        # 3. Segmentation
        gb = QtWidgets.QGroupBox("3. Segmentation"); v = QtWidgets.QVBoxLayout()
        
        # Toggle Overlay
        self.chk_show_seg = QtWidgets.QCheckBox("Show Cyan Overlay")
        self.chk_show_seg.setChecked(True)
        self.chk_show_seg.toggled.connect(self.toggle_segmentation_view)
        v.addWidget(self.chk_show_seg)

        # Params
        h = QtWidgets.QHBoxLayout()
        self.spin_p1 = QtWidgets.QSpinBox(); self.spin_p1.setRange(1,300); self.spin_p1.setValue(50)
        self.spin_p2 = QtWidgets.QSpinBox(); self.spin_p2.setRange(1,100); self.spin_p2.setValue(30)
        for s in [self.spin_p1, self.spin_p2]: s.valueChanged.connect(self.run_segmentation)
        h.addWidget(QtWidgets.QLabel("Edge:")); h.addWidget(self.spin_p1)
        h.addWidget(QtWidgets.QLabel("Circ:")); h.addWidget(self.spin_p2)
        v.addLayout(h)
        
        h2 = QtWidgets.QHBoxLayout()
        self.spin_minR = QtWidgets.QSpinBox(); self.spin_minR.setRange(5,500); self.spin_minR.setValue(20)
        self.spin_maxR = QtWidgets.QSpinBox(); self.spin_maxR.setRange(5,500); self.spin_maxR.setValue(60)
        for s in [self.spin_minR, self.spin_maxR]: s.valueChanged.connect(self.run_segmentation)
        h2.addWidget(QtWidgets.QLabel("MinR:")); h2.addWidget(self.spin_minR)
        h2.addWidget(QtWidgets.QLabel("MaxR:")); h2.addWidget(self.spin_maxR)
        v.addLayout(h2)
        gb.setLayout(v); l.addWidget(gb)

        # 4. Analysis
        gb = QtWidgets.QGroupBox("4. Analysis"); v = QtWidgets.QVBoxLayout()
        # Crop / ROI
        h_roi = QtWidgets.QHBoxLayout()
        self.btn_set_roi = QtWidgets.QPushButton("Set Analysis ROI (Crop)")
        self.btn_set_roi.setCheckable(True)
        self.btn_set_roi.clicked.connect(self.activate_roi_drawing)
        h_roi.addWidget(self.btn_set_roi)
        
        self.btn_clear_roi = QtWidgets.QPushButton("Reset ROI")
        self.btn_clear_roi.clicked.connect(self.clear_roi)
        h_roi.addWidget(self.btn_clear_roi)
        v.addLayout(h_roi)
        
        # Shrink
        h3 = QtWidgets.QHBoxLayout()
        h3.addWidget(QtWidgets.QLabel("Shrink ROI (px):"))
        self.spin_shrink = QtWidgets.QSpinBox(); self.spin_shrink.setRange(0,50); self.spin_shrink.setValue(5)
        self.spin_shrink.valueChanged.connect(self.analyze_data) # Auto-update on shrink change too
        h3.addWidget(self.spin_shrink)
        v.addLayout(h3)
        
        # BG Mode
        h4 = QtWidgets.QHBoxLayout()
        self.rb_auto = QtWidgets.QRadioButton("Auto BG"); self.rb_auto.setChecked(True)
        self.rb_man = QtWidgets.QRadioButton("Manual BG"); 
        self.rb_man.toggled.connect(lambda: self.viewer.update() or self.btn_draw.setEnabled(self.rb_man.isChecked()))
        h4.addWidget(self.rb_auto); h4.addWidget(self.rb_man)
        v.addLayout(h4)
        
        self.btn_draw = QtWidgets.QPushButton("Draw BG Rect"); self.btn_draw.setCheckable(True); self.btn_draw.setEnabled(False)
        self.btn_draw.clicked.connect(lambda: setattr(self.viewer, 'drawing_bg', self.btn_draw.isChecked()))
        v.addWidget(self.btn_draw)
        
        # Graph Selector
        v.addWidget(QtWidgets.QLabel("<b>Graph Channel:</b>"))
        self.combo_plot_ch = QtWidgets.QComboBox()
        # Connect to analyze_data for instant graph updates
        self.combo_plot_ch.currentIndexChanged.connect(self.analyze_data)
        v.addWidget(self.combo_plot_ch)

        # Actions
        h5 = QtWidgets.QHBoxLayout()
        b_calc = QtWidgets.QPushButton("Refresh Stats"); b_calc.clicked.connect(self.analyze_data)
        b_exp = QtWidgets.QPushButton("Export Data"); b_exp.clicked.connect(self.export_excel)
        h5.addWidget(b_calc); h5.addWidget(b_exp)
        v.addLayout(h5)

        self.lbl_stats = QtWidgets.QLabel("Stats: N/A")
        v.addWidget(self.lbl_stats)
        gb.setLayout(v); l.addWidget(gb)

        # 5. Plot
        self.plot_canvas = PlotCanvas(self, width=4, height=3)
        l.addWidget(self.plot_canvas)
        
        btn_save_plot = QtWidgets.QPushButton("Save Plot Image")
        btn_save_plot.clicked.connect(self.save_plot_image)
        l.addWidget(btn_save_plot)
        
        self.lbl_info = QtWidgets.QLabel("Hover for info...")
        self.lbl_info.setStyleSheet("color: blue; font-weight: bold;")
        l.addWidget(self.lbl_info)
        l.addStretch()

    def load_image(self):
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Open', '', "Images (*.tif *.tiff *.ome.tif)")
        if not fname: return
        with tifffile.TiffFile(fname) as tif:
            data = tif.asarray()
        if data.ndim == 2: data = data[np.newaxis, :, :]
        elif data.ndim == 3 and data.shape[0] > data.shape[2]: data = np.moveaxis(data, 2, 0) # Fix (H,W,C)
        
        self.channels = [data[i] for i in range(data.shape[0])]
        
        # Clear Layouts
        for i in reversed(range(self.ch_layout.count())): 
            self.ch_layout.itemAt(i).widget().setParent(None)
        
        self.channel_widgets = []
        self.combo_plot_ch.clear()
        
        # Temporarily block signals to prevent premature triggering
        self.combo_plot_ch.blockSignals(True)
        for i in range(len(self.channels)):
            item = ChannelControlItem(i, f"Channel {i+1}")
            item.changed.connect(self.update_viewer)
            self.ch_layout.addWidget(item)
            self.channel_widgets.append(item)
            self.combo_plot_ch.addItem(f"Channel {i+1}", i)
        self.combo_plot_ch.blockSignals(False)
        
        if len(self.channels) > 1: self.combo_plot_ch.setCurrentIndex(1) # Default to first fluor
        
        self.update_viewer()
        self.viewer.fit_to_window()
        self.run_segmentation()
        self.analyze_data() # Initial Calculation

    def update_viewer(self):
        layers = []
        for w in self.channel_widgets:
            layers.append({
                'data': self.channels[w.index],
                'visible': w.chk_visible.isChecked(),
                'color': w.combo_color.currentText(),
                'clip': w.slider_clip.value()
            })
        self.viewer.set_data(layers, self.viewer.circles, self.viewer.valid_mask)

    def toggle_segmentation_view(self):
        self.viewer.show_circles = self.chk_show_seg.isChecked()
        self.viewer.update()

    def run_segmentation(self):
        if not self.channels: return
        img = self.channels[0] # BF
        blur = cv2.GaussianBlur(img, (9,9), 2)
        norm = cv2.normalize(blur, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        
        circles = cv2.HoughCircles(
            norm, cv2.HOUGH_GRADIENT, 1, 
            minDist=self.spin_minR.value()*2,
            param1=self.spin_p1.value(), param2=self.spin_p2.value(),
            minRadius=self.spin_minR.value(), maxRadius=self.spin_maxR.value()
        )
        
        detected = []
        if circles is not None:
            detected = np.round(circles[0, :]).astype("int").tolist()
        
        self.viewer.set_data(self.viewer.channels_data, detected, None)
        self.analyze_data() # Update stats on new segmentation

    def get_bg_val(self, ch_idx):
        img = self.channels[ch_idx]
        
        # 1. Determine the "Universe" (Full image or Crop)
        if self.viewer.analysis_roi:
            rx, ry, rw, rh = map(int, self.viewer.analysis_roi)
            # Clip to image bounds
            rx = max(0, rx); ry = max(0, ry)
            rw = min(rw, img.shape[1] - rx); rh = min(rh, img.shape[0] - ry)
            universe = img[ry:ry+rh, rx:rx+rw]
            offset_x, offset_y = rx, ry
        else:
            universe = img
            offset_x, offset_y = 0, 0

        # 2. Manual BG Mode (User draws a yellow box)
        if self.rb_man.isChecked() and self.viewer.bg_roi_rect:
            bx, by, bw, bh = self.viewer.bg_roi_rect
            # Must intersect with universe? usually manual override ignores crop logic, 
            # but safer to just return the mean of that box directly.
            roi = img[int(by):int(by+bh), int(bx):int(bx+bw)]
            return np.mean(roi) if roi.size else 0
        
        # 3. Auto BG Mode (Empty Space inside Universe)
        mask = np.zeros(universe.shape, dtype=np.uint8)
        if self.viewer.circles:
            for (cx, cy, cr) in self.viewer.circles:
                # Shift circle coordinates to match the cropped universe
                lx = int(cx - offset_x)
                ly = int(cy - offset_y)
                if 0 <= lx < universe.shape[1] and 0 <= ly < universe.shape[0]:
                    cv2.circle(mask, (lx, ly), int(cr), 255, -1)
        
        bg_mask = cv2.bitwise_not(mask)
        return cv2.mean(universe, mask=bg_mask)[0]

    def analyze_data(self):
        if not self.viewer.circles: return
        
        ch_idx = self.combo_plot_ch.currentData()
        if ch_idx is None: return 
        
        shrink = self.spin_shrink.value()
        
        # 1. Get Background 
        bg_val = self.get_bg_val(ch_idx)
        
        # 2. Parse ROI & Calculate Area
        roi = self.viewer.analysis_roi
        if roi: 
            rx, ry, rw, rh = roi
            area = rw * rh
        else:
            h, w = self.channels[0].shape
            area = w * h
        
        vals = []
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            if not self.viewer.valid_mask[i]: continue
            
            # 3. ROI Filter
            if roi:
                if not (rx <= cx <= rx + rw and ry <= cy <= ry + rh):
                    continue

            eff_r = max(1, cr - shrink)
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(eff_r), 255, -1)
            
            raw = cv2.mean(self.channels[ch_idx], mask=mask)[0]
            vals.append(raw - bg_val)
            
        if vals:
            peak_kde, kde_x, kde_y = self.plot_canvas.plot(vals, f"Ch {ch_idx+1} Intensity")
            mu, std = np.mean(vals), np.std(vals)
            n_val = len(vals)
            density = n_val / area if area > 0 else 0
            
            # Formatted string with scientific notation for density
            self.lbl_stats.setText(f"N={n_val} | Conc={density:.2e} /pxÂ²\nMean: {mu:.1f} | Std: {std:.1f}\nKDE Peak: {peak_kde:.1f}")
        else:
            self.lbl_stats.setText("No droplets found in ROI.")
            self.plot_canvas.axes.clear()
            self.plot_canvas.draw()

    def export_csv(self):
        if not self.viewer.circles: return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save", "res.csv", "CSV (*.csv)")
        if not path: return
        
        shrink = self.spin_shrink.value()
        bgs = [self.get_bg_val(i) for i in range(len(self.channels))]
        
        data = []
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            row = {"ID": i, "Valid": self.viewer.valid_mask[i], "R_BF": cr, "R_Fluor": max(1, cr-shrink)}
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(row['R_Fluor']), 255, -1)
            
            for idx, img in enumerate(self.channels):
                raw = cv2.mean(img, mask=mask)[0]
                row[f"Ch{idx+1}_Raw"] = raw
                row[f"Ch{idx+1}_Net"] = raw - bgs[idx]
            data.append(row)
        pd.DataFrame(data).to_csv(path, index=False)
    
    def export_excel(self):
        if not self.viewer.circles: return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Excel", "results.xlsx", "Excel Files (*.xlsx)")
        if not path: return

        shrink = self.spin_shrink.value()
        
        # 1. Determine Area and ROI String
        roi_str = "Full Image"
        if self.viewer.analysis_roi:
            rx, ry, rw, rh = self.viewer.analysis_roi
            area = rw * rh
            roi_str = f"Crop (x={int(rx)}, y={int(ry)}, w={int(rw)}, h={int(rh)})"
        else:
            h, w = self.channels[0].shape
            area = w * h

        # 2. Setup Parameters
        params = {
            "Edge Thresh": self.spin_p1.value(),
            "Circ Thresh": self.spin_p2.value(),
            "Min/Max Radius": f"{self.spin_minR.value()}-{self.spin_maxR.value()}",
            "Shrink ROI": shrink,
            "Background Mode": "Manual" if self.rb_man.isChecked() else "Auto (Crop)" if self.viewer.analysis_roi else "Auto (Full)",
            "Analysis Region": roi_str,
            "Total Area (px^2)": area
        }
        df_params = pd.DataFrame(list(params.items()), columns=["Parameter", "Value"])

        # 3. Pre-calculate Backgrounds 
        bgs = [self.get_bg_val(i) for i in range(len(self.channels))]
        
        # 4. Filter Data (ROI)
        roi = self.viewer.analysis_roi
        if roi: rx, ry, rw, rh = roi

        data = []
        for i, (cx, cy, cr) in enumerate(self.viewer.circles):
            if roi:
                if not (rx <= cx <= rx + rw and ry <= cy <= ry + rh):
                    continue 

            row = {"ID": i, "Valid": self.viewer.valid_mask[i], "R_BF": cr, "R_Fluor": max(1, cr-shrink)}
            
            mask = np.zeros(self.channels[0].shape, dtype=np.uint8)
            cv2.circle(mask, (int(cx), int(cy)), int(row['R_Fluor']), 255, -1)
            
            for idx, img in enumerate(self.channels):
                raw = cv2.mean(img, mask=mask)[0]
                bg = bgs[idx]
                row[f"Ch{idx+1}_Raw"] = raw
                row[f"Ch{idx+1}_BG"] = bg
                row[f"Ch{idx+1}_Net"] = raw - bg
            
            data.append(row)
        
        df_details = pd.DataFrame(data)

        # 5. Summary Stats with Density
        stats_list = []
        if not df_details.empty:
            valid_df = df_details[df_details["Valid"] == True]
            
            for idx in range(len(self.channels)):
                col = f"Ch{idx+1}_Net"
                if col in valid_df.columns:
                    vals = valid_df[col].values
                    if len(vals) > 0:
                        mu, std = np.mean(vals), np.std(vals)
                        try:
                            kde = gaussian_kde(vals)
                            x = np.linspace(min(vals), max(vals), 200)
                            peak = x[np.argmax(kde(x))]
                        except: peak = 0
                        
                        n_val = len(vals)
                        density = n_val / area if area > 0 else 0
                        
                        stats_list.append({
                            "Channel": f"Ch {idx+1}",
                            "N (Count)": n_val,
                            "Area (px^2)": area,
                            "Density (N/px^2)": density,
                            "Mean": mu,
                            "Std Dev": std,
                            "KDE Peak": peak,
                            "Background Used": bgs[idx]
                        })
        
        df_stats = pd.DataFrame(stats_list)

        # 6. Write to Excel
        try:
            with pd.ExcelWriter(path) as writer:
                df_params.to_excel(writer, sheet_name='Summary', startrow=0, index=False)
                df_stats.to_excel(writer, sheet_name='Summary', startrow=len(df_params)+3, index=False)
                if not df_details.empty:
                    df_details.to_excel(writer, sheet_name='Droplet Data', index=False)
            QtWidgets.QMessageBox.information(self, "Success", "Export Complete")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"Failed to save:\n{e}")

    def save_plot_image(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Plot", "plot.png", "Images (*.png *.pdf)")
        if path:
            self.plot_canvas.figure.savefig(path)
    
    def get_local_bg(self, ch_img, cx, cy, r_inner, r_outer, all_circles):
        """
        Calculates median intensity of an annulus (donut) around the droplet,
        masking out neighbors to avoid contamination.
        """
        h, w = ch_img.shape
        
        # 1. Create the Annulus Mask (Donut)
        mask = np.zeros((h, w), dtype=np.uint8)
        cv2.circle(mask, (int(cx), int(cy)), int(r_outer), 255, -1)
        cv2.circle(mask, (int(cx), int(cy)), int(r_inner), 0, -1)
        
        # 2. Exclude ANY other droplet from this background area
        # (This prevents a bright neighbor from skewing the background high)
        if all_circles:
            for (ncx, ncy, nr) in all_circles:
                # If neighbor is close to our annulus, mask it out
                dist = np.sqrt((cx-ncx)**2 + (cy-ncy)**2)
                if dist < (r_outer + nr): 
                    cv2.circle(mask, (int(ncx), int(ncy)), int(nr), 0, -1)

        # 3. Calculate Median of remaining pixels
        # If the ring is totally full of neighbors, fallback to 0 or global mean
        locs = np.where(mask > 0)
        if len(locs[0]) == 0:
            return 0 
        
        bg_pixels = ch_img[locs]
        return np.median(bg_pixels)
    
    def activate_roi_drawing(self):
        self.viewer.drawing_roi = self.btn_set_roi.isChecked()
        self.viewer.drawing_bg = False # Turn off BG drawing if on
        self.btn_draw.setChecked(False)

    def clear_roi(self):
        self.viewer.analysis_roi = None
        self.viewer.update()
        self.analyze_data()

# --- Plotter ---
class PlotCanvas(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4):
        fig = Figure(figsize=(width, height), dpi=100)
        self.axes = fig.add_subplot(111)
        super().__init__(fig)
        self.setParent(parent)

    def plot(self, data, title):
        self.axes.clear()
        self.axes.hist(data, bins=30, density=True, alpha=0.5, color='skyblue', label='Hist')
        peak = 0
        kde_x, kde_y = None, None
        if len(data) > 1:
            try:
                kde = gaussian_kde(data)
                x = np.linspace(min(data), max(data), 200)
                y = kde(x)
                self.axes.plot(x, y, 'r-', lw=2, label='KDE')
                peak = x[np.argmax(y)]
                kde_x, kde_y = x, y
            except: pass
        self.axes.set_title(title)
        self.axes.legend()
        self.draw()
        return peak, kde_x, kde_y

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())